classdef Movie_TIFF
% Movie_TIFF is a wrapper for a stack of TIFF images, as generated by imaging
% software like MetaMorph. See Movie for interface details.
%

% TODO: first get this class to work with loading headers with every frame
% having a seperate entry. Then get everything working with gettraces. Then
% try to optimize the code by, for example, only reading the first frame's
% annotation.
%
% The readFrames() way of getting data is a reasonable interface, but it would
% be even cleaner if the data were wrapped almost like mmapPassthrough so that
% it appears to be a data "property" of the movie, but instead just contains
% pointers and methods to read the data. Could call it freadPassthrough. On the
% other hand, am I making things more complicated than needed?

properties (SetAccess=protected, GetAccess=public)
    % These varibles are part of the standard interface
    filenames = ''; % full path and filename to loaded file
    
    nX=0;       % size (in pixels) of x dimension (columns).
    nY=0;       % size (in pixels) of y dimension (rows).
    nFrames=0;  % number of images in the stack.
    
    timeAxis=[]; % wall time of the start of each frame (starts with zero).
    
    header = struct([]);

% end %end public properties
% 
% 
% properties (SetAccess=protected, GetAccess=protected),
    %dataOffsets = []; %offsets to data segments in the movie file, with
    %                  %one offset per plane (frame).
    movieHeaders = {};  %metadata for all movies (cells) and all frames.
    nFramesPerMovie = [];
end


methods
    
    function obj = Movie_TIFF( filenames )        
        if ~iscell(filenames),  filenames = {filenames};  end
        obj.filenames = filenames;
        
        % Read the TIFF file and get all useful header information. The data
        % sections are ignored. Data-access offsets are stored in tiffData.
        info = imfinfo( filenames{1} );
        obj.movieHeaders{1} = info;
        obj.header = info(1);
        
        % Extract basic image metadata
        obj.nX = info(1).Width;
        obj.nY = info(1).Height;
        obj.nFramesPerMovie(1) = numel(info);
        
        % If there are multiple files given, verify they are the same size
        % (etc).
        for i=2:numel(filenames),
            info = imfinfo( filenames{i} );
            obj.movieHeaders{i} = info;
            obj.nFramesPerMovie(i) = numel(info);
            
            % Verify dimensions are the same
            assert( info(1).Width==obj.nX && info(1).Height==obj.nY, ...
                           'Movies in series have different sizes!' );
        end
        
        obj.nFrames = sum( obj.nFramesPerMovie );
                
        % Generate an approximate time axis. The actual timestamps are in the
        % MM_private1 (UIC1, 33628) field untag tag #16 (CreateTime). The LONG
        % data element is a pointer to a LONG [date,time]. FIXME
        % If this is a MM TIFF stack, then we can get lots of metadata from
        % the description field. It's possibly the case also for MM TIFFs
        % and other TIFFs...
        
        % If this is a MM stack...
        if numel(info)==1 && isfield(info,'UnknownTags') && ...
                                      any( [info.UnknownTags.ID]==33628 ),
                                  
            obj.header.MM = parseMetamorphInfo( info.ImageDescription, 1);
            
            x = repmat( obj.header.MM.Exposure, [1 obj.nFrames] );
            obj.timeAxis = [0 cumsum(x(1:end-1))];
            
        else
            obj.timeAxis = 1:obj.nFrames; %FIXME
        end
        
    end %constructor
    
    
    % Data access methods. Data are only loaded when needed by these functions.
    function data = readFrames( obj, idxStart, idxEnd )
        
        % Parse input arguments.
        % First parameter can be a vector of indexes.
        if nargin==2,
            idx = reshape(idxStart, [1 numel(idxStart)]);
        else
            assert( idxEnd>=idxStart && idxEnd<=obj.nFrames && idxStart>=1 );
            idx = idxStart:idxEnd;
        end
        
        % Preallocate space for the output data.
        data = zeros( obj.nY,obj.nX,numel(idx), 'uint16' );
        
        framesRead=0;
        for i=idx,
            data(:,:,framesRead+1) = obj.readFrame(i);
            framesRead=framesRead+1;
        end
    end
    
    function data = readFrame( obj, idx )
        % Determine which file this frame number belongs to.
        movieFirstFrame = 1+cumsum([0 obj.nFramesPerMovie]);
        idxFile = find( idx>=movieFirstFrame, 1, 'last' );
        idx = idx - movieFirstFrame(idxFile)+1;

        data = imread( obj.filenames{idxFile}, ...
                          'Info',obj.movieHeaders{idxFile}, 'Index',idx );
    end
    
    
    
end %public methods



end %class Movie_TIFF





%% %%  Parse the Metamorph camera info tag into respective fields
% EVBR 2/7/2005, FJN Dec. 2007
function mm = parseMetamorphInfo(info, cnt)

% info   = regexprep(info, '\r\n|\o0', '\n');
info( info==char(0)  ) =char(10);
info( info==char(13) ) =char(10);

parse  = textscan(info, '%s %s', 'Delimiter', ':');
tokens = parse{1};
values = parse{2};

first = char(tokens(1,1));

k = 0;
mm = struct('Exposure', zeros(cnt,1));
for i=1:size(tokens,1)
    tok = char(tokens(i,1));
    val = char(values(i,1));
    %fprintf( '"%s" : "%s"\n', tok, val);
    if strcmp(tok, first)
        k = k + 1;
        if k>cnt, return; end
    end
    if strcmp(tok, 'Exposure')
        [v, c, e, pos] = sscanf(val, '%i');
        unit = val(pos:length(val));
        %return the exposure in milli-seconds
        switch( unit )
            case 'ms'
                mm(k).Exposure = v;
            case 'msec'
                mm(k).Exposure = v;
            case 's'
                mm(k).Exposure = v * 1000;
            otherwise
                warning('tiffread2:Unit', ['Exposure unit "',unit,'" not recognized']);
                mm(k).Exposure = v;
        end
    else
        switch tok
            case 'Binning'
                % Binning: 1 x 1 -> [1 1]
                mm(k).Binning = sscanf(val, '%d %*s %d')';
            case 'Region'
                mm(k).Region = sscanf(val, '%d %*s %d, offset at (%d, %d)')';
            otherwise
                field = strrep(tok,' ','_');
                
                if strcmp(val, 'Off')
                    mm(k).(field)=0;
                elseif strcmp(val, 'On')
                    mm(k).(field)=1;
                elseif isstrprop(val,'digit')
                    mm(k).(field)=str2double(val);
                else
                    mm(k).(field)=val;
                end
        end
    end
end

end
