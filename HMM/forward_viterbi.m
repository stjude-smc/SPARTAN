function [tLL, vPath, vLL] = forward_viterbi2(start_p, trans_p, emit_p)
% FORWARD_VITERBI   Decodes sequence of states from observations (HMM)
%
%   [LLt,PATH,LLv] = FORWARD_VITERBI(P0, A, B)
%   Finds the sequence of states (Viterbi PATH) with that is most
%   consistent with both the given observations and markov model
%   (high probability, LLv).  P0 are initial probabilities for each state,
%   A is the transition probability matrix, and B is a NxM matrix of
%   the probability the observation at time=t (1..N) was generated by
%   state s (1..M).

% Nice explainations:  http://www.comp.leeds.ac.uk/roger/HiddenMarkovModels/
% html_dev/viterbi_algorithm

% dbstop if error;

% Add a small number to all probabilities to prevent overflow (-Inf LL)
start_p = start_p+eps;
trans_p = trans_p+eps;
emit_p  = emit_p+eps;

%
[nStates,nObs] = size(emit_p);
assert( length(start_p)==nStates );

delta = zeros( nObs, nStates );  %partial probabilities
psi   = zeros( nObs, nStates );  %back pointers (most likely previous state)
% Maximal probability (and best path) that ends in state=i at time=t
% "If I am here, by what route is it most likely I arrived?"

ltp = log10( trans_p );
lep = log10( emit_p  );

% Initialization
delta(1,:) = log10( start_p(:).*emit_p(:,1) );

% Induction: calcualte probability at each timepoint
% pCurr = zeros(1,nStates);

for t=2:nObs,
    %delta_t(j) = MAX_i[ delta_t-1(i) * A(i,j) ]   * B(j)
    
    for j=1:nStates  %current state
        
        pCurr = delta(t-1,:)' + ltp(:,j);
        valmax = max(pCurr);
        
        psi(t,j) = find(pCurr==valmax,1);  %argmax, most likely state
        
        delta(t,j) = valmax + lep(j,t);  %partial prob. of state=j at time=t
        
%         if delta(t,j)>100,
%             error('Viterbi: Overload in partial probabilities');
%         end
    end
end

% Termination
valmax = max(delta(end,:));
argmax = find( delta(end,:)==valmax, 1 );
vLL = log( valmax );
tLL = log( sum(delta(:)) );

% Backtrace to determine most likely path
vPath = zeros(1,nObs);
vPath(nObs) = argmax;

for t=nObs-1:-1:1,
    vPath(t) = psi( t+1, vPath(t+1) );
end




